---
title: "Using Hangler"
author: "Roman Klapaukh"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

We are going to run through an example of using hangler to analyse a unit 
circle. 


First we need to generate our data set. This is equivalent to a human digitising
a curve. We come out with only a set of xy coordinates sampled along the shape. 

```{r}
library(hangler)
```

```{r}
theta = seq(0,2*pi, 0.1)

x = cos(theta)
y = sin(theta)

rm(theta)
```

We can now plot it and see our apeture.

```{r fig.caption="The unit circle"}
plot(x,y)
```

For convenience we want a variable to keep track of how many landmarks we have. 

```{r}
nPoints = length(x)
```

The next step is to get the spline coefficients

```{r}
centers = lapply(1:nPoints, function(i){
  ip = i - 1
  inext = i + 1

  ip = ifelse(ip < 1, nPoints - ip, ip) 
  inext = ifelse(inext > nPoints, inext- nPoints, inext) 
  findCenter(x[ip],y[ip],x[i],y[i],x[inext],y[inext])
})

xc = sapply(centers, function(c) c[1])
yc = sapply(centers, function(c) c[2])


tangents = sapply(1:nPoints, function(i) findTangentAngle(xc[i], yc[i], x[i], y[i]))

deli = sapply(1:nPoints, function(i) {
  inext = i + 1
  inext = ifelse(inext > nPoints, inext- nPoints, inext) 

  tryCatch(solveDeli(x[inext] - x[i], y[inext] - y[i], tangents[i], tangents[inext]), error =
          function(e){ 
            print(e)
            stop(paste(e,"\niter",i, inext))
          }
  )
})

ds = sapply(1:nPoints, function(i) {
  inext = i + 1
  inext = ifelse(inext > nPoints, inext- nPoints, inext) 

  tryCatch(solveDs(x[inext] - x[i], deli[i], tangents[i], tangents[inext]), error =
          function(e){ 
            print(e)
            stop(paste(e, "\niter",i, inext))
          }
  )
})

ds = abs(ds)

si = cumsum(c(0,ds))
```


Then resample the spline

```{r}
samples = sapply(seq(0,si[length(si)],length = 1024), function(s){
  i = which(si < s)
  if(length(i)==0){
    i = 1
  }else{
    i = max(i)
  }

  inext = i + 1
  sinext = ifelse(inext > length(si), inext-length(si), inext)
  tinext = ifelse(inext > length(tangents), inext-length(tangents), inext)

  computeSpline(s, si[i], si[sinext], tangents[i], tangents[tinext], deli[i])

})
```


We can now plot the resampled curve to make sure that it looks the same as the
original. Note, however, that the new curve does not preserve the size of the
original.

```{r}
with(tangentsToXY(samples), plot(x, y))
```

First we reset the curve to start from 0.
Then we find the difference between the sampled tangents and the uni circle. 
We can now run the FFT over the resampled spline. 

```{r}
diffs = diff(samples)

shortestAngle = function(theta){
  if(theta >= 2*pi){
    theta = theta %% (2*pi)
  } else if(theta <= -2*pi){
    theta = theta  %% (-2*pi)
  }
  if(theta > pi){
    return(theta - 2*pi)
  }else if(theta < -pi){
    return(2*pi + theta)
  }else{
    return(theta)
  }
}

diffs = sapply(diffs, shortestAngle)

samples = cumsum(c(0,diffs))

samples= sapply(1:length(samples), function(i) samples[i] - (pi/512)*(i-1)) 
coeffs = fft(samples)/length(samples)
```

We start by taking only the first 30 and now trying to reconstruct the original
curve. 

```{r}
coeffs = coeffs[1:30]
```


We now want to go back from fft coefficients to fft parameters to go backwards.

```{r}
backCoeffs = fftoToCoeffs(coeffs)
```

Now we can reconstruct the original curve. 

```{r}
reconstructedTangents = sapply(seq(0,2*pi,length.out=1024),
      function(s) getTangentAtS(s,backCoeffs))
with(tangentsToXY(reconstructedTangents), plot(x, y,col=rainbow(1024)))
```